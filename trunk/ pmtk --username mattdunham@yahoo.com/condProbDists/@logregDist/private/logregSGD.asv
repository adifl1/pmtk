function [w, output] = logregSGD(X, y, lambda, varargin)
% X(i,:) is i'th case
% y(i) = 0 or 1
% lambda l2 regularizer
% optional arguments as in minFunc - MaxIter and TolX
%
% output currently only contains ftrace

[maxIter, tolX] = process_options(varargin, ...
  'maxIter', 1000, 'tolX', 1e-4);

if ~isempty(find(y==-1)), error('y must be 0,1'); end
[n d] = size(X);
w = rand(d,1);
wold = w;
ypm1 = pm1(y);
ftrace = [];
for iter=1:max_iter
  errors = 0;
  for i=1:n
    xi = X(i,:)';
    mui = sigmoid(w'*xi);
    yhati = sign(w'*xi);
    gi = (y(i)-mui)*xi - (lambda/n)*w;
    eta = 1/(iter+1); % step size decay
    w = w + eta*gi;
    if yhati ~= y(i)
      errors = errors + 1;
    end
  end
  if nargout > 1
    f = logregNLLgradHess(w, X, y, lambda);
    ftrace(iter) = f;
  end
  incr = norm(wold -w)/norm(wold);
  %fprintf('Iteration %d, errors = %d, incr = %f\n', iter, errors,incr);
  if (errors==0 || incr < tolX)
    break;
  end
  wold = w;
end
output.ftrace = ftrace;
end

   