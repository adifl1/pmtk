classdef mvn < handle  
  % multivariate normal p(X|mu,Sigma) 
  
  properties(SetAccess = private)
    mu;
    Sigma;
    
    % If we observe parts of x, then we shrink mu and Sigma
    % so they only reflect the distribution of the hidden parts.
    % When we reset, we restore the original params, stored below.
    origMu;
    origSigma;
    x;
  end
  
  properties(Dependent)
    ndims; % mu may change in length if we observe x
  end
  
  methods
    %% Main methods
    function m = mvn(arg1, arg2)
      % mvn(mu, Sigma) or mvn('rnd', ndims)
      % You cannot change mu, Sigma once the object is created.
      if nargin == 0
        mu = []; Sigma = [];
      elseif ischar(arg1) && strcmp(arg1, 'rnd')
        d = arg2;
        mu = randn(d,1); Sigma = randpd(d);
      else
        mu = arg1; Sigma = arg2;
      end
      m.mu  = mu;
      m.Sigma = expandSigma(Sigma, ndims(m));
      m.origMu = mu;
      m.origSigma = Sigma;
    end

    function X = sample(m, n)
      % X(i,:) = sample for i=1:n
      if statstoolboxInstalled
        X = mvnrnd(mean(m), cov(m), n);
      else
        error('not yet implemented')
      end
    end

    function mu = mean(m)
      if isempty(m.x)
        mu = m.mu;
      else
        % set mean of observed variables to their observed values
        [V,H] = findVisHid(m.x);
        mu = ones(1, m.ndims);
        mu(H) = m.mu;
        mu(V) = m.x(V);
      end
    end


    function C = cov(m)
      if isempty(m.x)
        C = m.Sigma;
      else
        % set cov of observed variables to 0
        d = m.ndims;
        [V,H] = findVisHid(m.x);
        Cbig = zeros(d,d);
        Cbig(H,H) = m.Sigma;
        C = Cbig;
      end
    end

    function mu = mode(m)
      mu = mean(m);
    end

    function mm = marginal(m, dims)
      % Returns a new mvn object
      mu = mean(m); C = cov(m);
      mm = mvn(mu(dims), C(dims,dims));
      removeVisible(mm, m.x(dims));
    end

    function observe(m, arg1, arg2)
      % observe(m, Vvars, Vvals) or observe(m, x)
      % where x is a vector with NaNs indicating hidden variables.
      % We condition on the visible values Vvars=Vvals
      % as well as all previously observed data (until a reset is done).
      if nargin == 2
        x = arg1;
        assert(length(x)==m.ndims);
        [V, H] = findVisHid(x);
      else
        V = arg1;
        d = m.ndims;
        H = setdiff(1:d, V);
        x = NaN*ones(1, d);
        x(V) = arg2;
      end
      if isempty(m.x) % no old data
        [m.mu, m.Sigma] = gaussCondition(m.mu, m.Sigma, V, x(V));
        m.x  = x;
        return;
      end
      % need to merge new data with old (sequential updating)
      xold = m.x;
      [Vold,Hold] = findVisHid(xold);
      % Check that not observing same variable more than once
      % (since once a variable is observed it is 'removed')
      ndx = intersect(Vold, V);
      if ~isempty(ndx)
        fprintf('observing variable more than once; do a reset first\n');
        return
      end
      % We condition Hold on V, but Hold is a reduced dimensional Gaussian
      ndx = lookupIndices(V, Hold);
      [m.mu, m.Sigma] = gaussCondition(m.mu, m.Sigma, ndx, x(V));
      % Now merge the new x with the old
      x(Vold) = xold(Vold);
      m.x = x;
    end

    function reset(m)
      % Undo effect of observing evidence
      m.x = [];
      m.mu = m.origMu;
      m.Sigma = m.origSigma;
    end
    
    function 

    %% Dependendent methods
    function d = get.ndims(m)
      d = length(m.origMu);
    end

    %% Setters/ getters
    %{
    function set.mu(m, mu)
      m.mu = mu;
      m.origMu = mu;
    end

    function set.Sigma(m, Sigma)
      m.Sigma = Sigma;
      m.origSigma = Sigma;
    end
%}
    
  end % methods

  
  methods(Access=private)

    function removeVisible(m, x)
      % Remove components of mu, Sigma corresponding to visible variables
      % to prevent having Cov=0.
      [V,H] = findVisHid(x);
      m.mu = m.mu(H);
      m.Sigma = m.Sigma(H,H);
      m.x = x;
    end

  end
end