function handles = initFigures(nrows,ncols,varargin)
% Optimally lay out blank figures on the screen and return their handles.
% Figures are laid out from top to bottom and left to right (just like a
% Matlab matrix). total <= nrows*ncols*depth figures are created and
% displayed. 
%
% nrows             (default = 2) The number of figures to tile from top to
%                                 bottom.
%
% ncols             (default = 3) The number of figures to tile from left 
%                                 to right
%
%
% Note, if nrows, ncols not specified, the 6 figures are made square.
%
% NAMED PARAMETERS (all measurements are in pixels)
%
% total             (default = nrows*ncols*depth) The number of figures in 
%                    total to display. Must be less than nrows*ncols*depth
%                    and greater than 1. Entries in the return value,
%                    handles, not corresponding to valid figure handles are
%                    0.
%
% monitor           (default = 1)  If there is more than one monitor, 
%                   specify which monitor the figures should be displayed 
%                   on here. The main monitor is 1, the second monitor is 2
%                   (even if its 'to the left' of the main monitor).
%
% square            (default = false) If false, figures take up as much
%                                     space as possible, both vertically 
%                                     and horizontally. If true, figures 
%                                     are forced to be square. 
%
% depth             (default = 1)     The number of levels deep to display
%                                     figures. A setting of 2 for example
%                                     will 'double up' figures at each
%                                     location, one behind the other. 
%
% SIZE SPECIFICATIONS
%
% intergapH         (default = 40)  The horizontal gap, between figures.
%
% intergapV         (default = 20)  The vertical gap, between figures.
%
% gapH              (default = 10)  The gap on the left and right side of
%                                   the screen.
%
% lowergap          (default = 50)  The gap at the bottom of the screen,
%                                   (need to make room for the start bar).
%
% uppergap          (default = 10)  The gap at the top of the screen.
%
% toolsize          (default = 50)  The size of each figure toolbar needs
%                                   to be accounted for separately. This is
%                                   an estimate of its height.
%
% RETURN VALUES
%
% handles                             A matrix of figure handles.
%                                     handles(n,m,r) returns the figure n
%                                     rows down, m cols over, and r levels
%                                     from the back. handles(k) returns the kth
%                                     figure to be displayed. Note by
%                                     default, r = 1 and so handles(m,n) is
%                                     sufficient. If total < nrows*ncols*depth,
%                                     the rest of the entries are 0.

% newfig        if 
%
% Code by Matthew Dunham
%
[monitor,intergapH,intergapV,gapH,lowergap,uppergap,toolsize,square,depth,total] = ...
                                               process_options(varargin,...
                                              'monitor'        ,1     ,...
                                              'intergapH'      ,40    ,...
                                              'intergapV'      ,20    ,...
                                              'gapH'           ,10    ,...
                                              'lowergap'       ,50    ,...
                                              'uppergap'       ,10    ,...
                                              'toolsize'       ,50    ,...
                                              'square'         ,false ,...
                                              'depth'          ,1     ,...
                                              'total'          ,'all', ...
                                              'newfig',        'false');

                                          
if(nargin == 0)
    nrows = 2;
    ncols = 3;
    total = 6;
    square = true;
end 

if(strcmp(total,'all'))
    total = nrows*ncols*depth;
end

if(total < 1 || total > nrows*ncols*depth)
    error('total must be > 0 and < nrows*ncols*depth');
end
                                          
set(0,'Units','pixels');       

monitorSizes = get(0,'MonitorPositions');  % Get monitor sizes and positions

if(monitor > size(monitorSizes,1))
    error('INITFIGURES:NoSuchMonitor',['Can''t Find Monitor ',num2str(monitor)])
end

MINWIDTH  = 108;                            % minimum width for a figure 
MINHEIGHT = 10;                             % minimum height for a figure

uppergap = uppergap + toolsize;             
intergapV = intergapV + toolsize;

screenWidth  = monitorSizes(monitor,3) - monitorSizes(monitor,1) + 1;
screenHeight = monitorSizes(monitor,4) - monitorSizes(monitor,2) + 1;

figureWidth  = fix((screenWidth - 2*gapH - (ncols-1)*intergapH)/ncols);
figureHeight = fix((screenHeight - lowergap - uppergap - (nrows-1)*intergapV)/nrows);
if(figureWidth < MINWIDTH || figureHeight < MINHEIGHT)
    error('Too many figures to fit on the screen');
end

if(square)
   if(figureHeight < figureWidth)
      diff = figureWidth - figureHeight;
      figureWidth = figureHeight;
      if(figureWidth < MINWIDTH)
         diff = diff - (MINWIDTH - figureWidth); 
         figureWidth = MINWIDTH;
      end
      gapH = ceil(gapH + 0.5*diff*ncols);
   end
   if(figureWidth < figureHeight)
      diff = figureHeight - figureWidth;
      figureHeight = figureWidth;
      lowergap = lowergap + diff*nrows;
   end
    
end


startH = monitorSizes(monitor,1) + gapH;


% We start with the figure at the top left. This calculation is as
% complicated as it is to make sure we get the correct starting point with
% multiple displays and possibly changing resolutions. 
ssize = get(0,'ScreenSize');
offset = 1-ssize(2);
startV = (monitorSizes(1,4) - monitorSizes(monitor,4)+1) + lowergap + (figureHeight+intergapV)*(nrows-1) + offset;

diffH =  figureWidth + intergapH;      
diffV = -figureHeight - intergapV;

handles = zeros(nrows,ncols,depth);
counter = 1;
for d=1:depth
    for col=1:ncols
        for row=1:nrows
            position = [startH+(col-1)*diffH,startV+(row-1)*diffV,figureWidth,figureHeight];
            if newfig
              handles(row,col,d) = figure('Units','pixels','Position',position,'toolbar','none');
            else
             handles(row,col,d) = figure(counter);
              set(gcf,'Units','pixels','Position',position,'toolbar','none');
            end
            counter = counter + 1;
            if(counter > total),return,end
        end
    end
end

end